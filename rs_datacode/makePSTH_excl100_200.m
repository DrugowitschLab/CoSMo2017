function [psth_d,psth_s] = makePSTH_excl100_200(st,ston,sac,dot_ax,sac_ax)% function [psth_d,psth_s] = makePSTH(st,ston,sac,dot_ax,sac_ax)%% NOTE: this version excludes XX ms before sac onset in the psth wrt stimon%% Produces PSTHs calculated wrt dots-on (psth_d) and sac (psth_s), along % time axes specified in dot_ax and sac_ax.  The resolution of the time% axes determines the resolution of the psth (see EXAMPLE below).%% st..................an ntrials-by-1 cell array of spike times% ston and sac........ntrials-by-1 vectors of dots-on and sac times% - Please enter a sac time, even if it's just the last tic% dot_ax and sac_ax...time vectors specifying the time axis for the psth.% - Note that if either dot_ax or sac_ax are empty, only the non-empty PSTH %   will be calculated.% - EXAMPLE: if dot_ax=[-100:20:5000], psth_d will be calculated from 100 %   msec before to 5000 msec after the dots are turned on, at a%   resolution of 20 msec.%% For PSTHs calculated wrt dots-on, this function always excludes spikes% earlier than 100 ms before the eye movement, and for PSTHs calculated wrt% sac, this function always cuts off the spikes 200 ms after the dots on.% This is where the name of the function comes from.% MM 11/99% MKMK 6/04 added documentation for publishing on the web% how many trialstot_tr = length(st);%dot_ax = time to start wrt dots on, resolution, time to end, also wrt dots%on%sac_ax = time to start wrt sac, resolution, time to end, also wrt sacif ~isempty(dot_ax)   lim_dots = [dot_ax(1) dot_ax(end)];endif ~isempty(sac_ax)  lim_sac = [sac_ax(1) sac_ax(end)];endstv_d = [];stv_s = [];tv_d = [];tv_s = [];% loop through all trials (one coherence sent in to this function at a% time, so all trials here are from one coherence)%for id = 1:20for id = 1:tot_tr  st_f = st{id};    dot = round(ston(id));  eye = round(sac(id));  RT = eye - dot;    if ~isempty(dot_ax)        % for the traces that are aligned to the dots on    % First do start at time determined by user wrt dots on (usually a    % negative number so that we plot a bit before the dots on)    trig = dot;    tstart = dot + lim_dots(1);    % Always end dot on psth 100 ms before eye movement    tend = eye - 100;    % choose spike times greater than tstart and less than tend    inepoch = st_f>=tstart & st_f<=tend;    % make a column of spike times, subtracting off the trigger so that    % all spike times are now wrt the trigger.  Since we are in a loop, we    % just adds new trials to the end, so all trials in one vector.      stv_d = [stv_d; st_f(inepoch)-trig];    % make a column of all possible spike times for each trial wrt trigger.      % Each trial has different possible spike times, depending on when the     % saccade occurred.     tv_d = [tv_d;([tstart:1:tend]-trig)'];  end    if ~isempty(sac_ax)    % Then do wrt sac    trig = eye;    % Always start sac psth 200 ms after dots on    tstart = dot+200;    % End time at time determined by adding eye (time of saccade) to a time    % determined by the user (wrt sac)     tend = eye + lim_sac(2);    % do same as above for spikes wrt to sac    inepoch = st_f>=tstart & st_f<=tend;    stv_s = [stv_s; st_f(inepoch)-trig];    tv_s = [tv_s;([tstart:1:tend]-trig)'];  end      end% there will be some dividing by zero here, so lets get rid of the pesky% warninings - for versions of matlab earlier than matlab 6.5 just use % warning offwarning off MATLAB:divideByZeroif ~isempty(dot_ax)    % bins all spikes in the bins set up by dot_ax, divides this by the    % number of possible spikes for each trial (based on when the trial    % begins and ends), gives fraction of possible spikes that were actual    % spikes. Multipying by 1000 converts to seconds.     % note that hist centers the bins on the numbers in dot_ax, so the    % first and last bin can be wierd, because they will not necessarily be    % evenly spaced like the rest of the bins.  Turns out that this is not    % actually a problem, since the bin varies by trial, and it still gives    % us a fraction of spikes out of possible spikes for each trial.  We    % don't care as much about the end points anyway.      q = (hist(stv_d,dot_ax))./(hist(tv_d,dot_ax))*1000;  psth_d=q; else  psth_d=[];endif ~isempty(sac_ax)  q = (hist(stv_s,sac_ax))./(hist(tv_s,sac_ax))*1000;  psth_s=q;else  psth_s=[];end